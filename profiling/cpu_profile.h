/*
 * FileName: cpu_profile.h
 * Author: jattle
 * Descrption: parsing and data convertion utilities for gperftools CPU Profile.
 * now you can parse cpu profile data generated by gperftools, and convert it into symbolized profile,
 * it is efficient for online processing, 2000 times faster then pprof tool for parsing and converting 2000 samples profile.
 */

#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

#include "profiling/io/profile_io.h"

/// @brief Function call stack, generally consists of stack frame pointers
struct CallStack {
  size_t sample_count{0};
  std::vector<void*> ptrs;
};

inline bool operator==(const CallStack& l, const CallStack& r) {
  return l.sample_count == r.sample_count && l.ptrs == r.ptrs;
}

namespace pprofcpp {
class SymbolLocator;

enum class CPUProfileRetCode {
  kOK = 0,
  kNoProgramPath = 1,
  kGenProfileFailed = 2,
  kEmptyStack = 3,
  kSearchSymbolFailed = 4,
};

enum class RawProfileType {
  kPProfCompatible = 0,  // symbolized profile generated by pprof(with call ptr subtracted by one)
  kFixedRaw = 1,         // fixed raw profile(different binary specifier, attached with original profile data, not compatible with pprof tool)
};

struct RawProfileMeta {
  std::string program_path;  // absolute path of program binary
  RawProfileType profile_type{RawProfileType::kPProfCompatible};
};

/// @brief  gperftools CPU Profile
// only parse binary header & profile records now, with text mapping objects ignored
// because we only focus on runtime analysis and realtime mapping objects can be parsed from /proc/self/maps
// not thread-safe
class CPUProfile {
 public:
  explicit CPUProfile(const std::string& filename) : profile_file_(filename) {
    this->is_ = std::make_unique<std::ifstream>(filename.c_str(), std::ios_base::binary);
  }
  explicit CPUProfile(std::unique_ptr<std::istream> is) : is_(std::move(is)) {}
  ~CPUProfile() = default;
  // @brief parse whole profile file
  ReaderRetCode Parse();
  // @brief convert CPU profile as text
  std::string ToString();
  // @brief return address to symbol(function provided by symbol parser) mapping for this profile
  const std::unordered_map<void*, std::string>& GetSymbolMapping(SymbolLocator* parser) {
    if (!stacks_.empty() && symbol_mapping_.empty()) {
      GenerateSymbolMapping(parser);
    }
    return symbol_mapping_;
  }
  // @brief generate raw profile(similar to file genreated by pprof --raw)
  CPUProfileRetCode GenerateRawProfile(const RawProfileMeta& meta, SymbolLocator* locator, std::string* profile);
  // @brief get profile record num, equivalent to distinct callstack num
  size_t GetRecordNum() const {
    return record_num_;
  }
  // @brief get sample num, equivalent to real sampling times
  size_t GetSampleNum() const {
    return sample_num_;
  }

 private:
  CPUProfileRetCode GenerateRawSymbols(SymbolLocator* locator, std::string* symbols);
  CPUProfileRetCode GenerateSymbolMapping(SymbolLocator* locator);
  int ParseMapsText(const std::string& maps_text);
  CPUProfileRetCode GenerateBinaryProfile(const RawProfileMeta& meta, std::string* content);
  static void ReplaceBuildSpecifier(const std::string& pat, const std::string& target, std::string& line);

  std::string profile_file_;  // profile file path holded
  std::unique_ptr<std::istream> is_;
  // following 5 fields belong to profile binary header
  CPUProfileBinaryHeader binary_header_;
  size_t record_num_{0};  // profile record num
  size_t sample_num_{0};  // profile sample num
  size_t ptr_num_{0};     // address num(not dedupped)
  std::vector<CallStack> stacks_;
  std::unordered_map<void*, std::string> symbol_mapping_;  // mapping from backtrace addr to demangled symbol name
  std::vector<std::string> proc_maps_items_;               // proc maps items
};
}  // namespace pprofcpp